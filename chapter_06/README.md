# Chapter 06. Applied WebAssembly: Legacy Code in the Browser

This chapter introduces usage of Emscripten (LLVM platform based) toolchain.

## "Hello, World!" using Emscripten

> Note: In this chapter we will need multiple dependencies. Using the `nix-shell` approach
> and the Git repository from the main [README.md](../README.md) file, we could set-up our
> environment as follows:

```shell
~/repos/bash-utils/nix/dynamic-nix-shell.sh compiled js
unpacking 'https://github.com/NixOS/nixpkgs/archive/035f8c0853c2977b24ffc4d0a42c74f00b182cd8.tar.gz' into the Git cache...
info: using existing install for 'stable-x86_64-unknown-linux-gnu'
info: default toolchain set to 'stable-x86_64-unknown-linux-gnu'

  stable-x86_64-unknown-linux-gnu unchanged - rustc 1.79.0 (129f3b996 2024-06-10)
```

Using the Emscripten C compiler, we tell it to compile the C code and generate
some JavaScript scaffolding. After that we may run the resuling file in Node.js:

```shell
emcc hello.c -o hello.js
cache:INFO: generating system headers: sysroot_install.stamp... (this will be cached in "/home/vasilegorcinschi/.emscripten_cache/sysroot_install.stamp" for subsequent builds)
cache:INFO:  - ok
...
system_libs:INFO: compiled 27 inputs in 0.64s
cache:INFO:  - ok
cache:INFO: generating system asset: symbol_lists/de03afcd05285bf3a092555b24db5682ffadd7d5.json... (this will be cached in "/home/vasilegorcinschi/.emscripten_cache/symbol_lists/de03afcd05285bf3a092555b24db5682ffadd7d5.json" for subsequent builds)
cache:INFO:  - ok
[nix-shell:~/repos/wasm_definitive_guide/chapter_06]$ ls -halF | grep hello
-rw-rw-r--  1 vasilegorcinschi vasilegorcinschi   76 Jan 25 16:41 hello.c
-rw-r--r--  1 vasilegorcinschi vasilegorcinschi  54K Jan 25 16:49 hello.js
-rwxr-xr-x  1 vasilegorcinschi vasilegorcinschi  15K Jan 25 16:49 hello.wasm*
[nix-shell:~/repos/wasm_definitive_guide/chapter_06]$ node hello.js
Hello, World!
```

### Link common JS and CSS files

```shell
cd chapter_06/
# supposing you are in chapter_02 folder already
ln -s ../common common
```

### Run the generated `hello.js` file in the browser

To preview [hello.html](hello.html) file that runs [hello.wasm](hello.wasm) file the instructed step is:

```shell
# assumes presence of python3 on your host system
python3 -m http.server 10003
```

Then navigate to `localhost:10003/hello.html`. It is noteworthy, that with the code generated by Emscripten
we no longer needed to import the previously used [utils.js](common/utils.js).

## Bitmap project

Project under [bitmap](./bitmap) directory showcases porting an exsting (third-party) application to WebAssembly.

Emscripten has "drop-in replacements" for tools like `cc`, `make`, and `configure`. The book's author, Brian Sletten,
has chosen [Arash Partow's website](https://www.partow.net/) to pick from a collection of useful C++ code.

Navigate inside `bitmap` with `cd bitmap` and run `make` to generate `.wasm` and `.js` files:

```shell
[nix-shell:~/repos/wasm_definitive_guide/chapter_06/bitmap]$ make
em++ -ansi -pedantic-errors -Wall -Wall -Werror -Wextra -o bitmap_test.js bitmap_test.cpp -L/usr/lib -lstdc++ -lm -s FORCE_FILESYSTEM=1 -s ALLOW_MEMORY_GROWTH=1  -s INVOKE_RUN=0 -s EXPORTED_RUNTIME_METHODS="['callMain']"
cache:INFO: generating system asset: symbol_lists/1efd99bf593fac835273a46f24baa9f8895acf5d.json... (this will be cached in "/home/vasilegorcinschi/.emscripten_cache/symbol_lists/1efd99bf593fac835273a46f24baa9f8895acf5d.json" for subsequent builds)
cache:INFO:  - ok
```

### Compiler options building with Emscripten

Here are the explanations for some of the flags and options used in [Makefile](bitmap/Makefile).

> This is not the same as the original Makefile from the website above. The original one used C++ compiler (`g++`)

- `COMPILER`: used `em++` to build with Emscripten
- `OPTIONS`, for compiling options: 
  - `FORCE_FILESYSTEM=1` - Our library expects to be able to write to the filesystem. Out of the box, it is not alled for JavaScript apps running in browsers. By enabling this flag, we enable a filesystem abstraction that will write to local storage available by adding a compiler directive. Thus Emscripten, will simulate a filesystem.
  - `ALLOW_MEMORY_GROWTH=1` - This simulates WebAssembly's memory module, that we've previously declared manually (64B per page with ability to demand more pages).
  - `INVOKE_RUN=0` - Doesn't invoke the program, when it is loaded
  - `EXPORTED_RUNTIME_METHODS="['callMain', 'cwrap']"` - Used in conjunction, with the previous flag, list methods that will be available in the invoking environment
    - `callMain` above points to the entry point of the binary
    - `cwrap` - a convenince method from Emscripten that will generate a JavaScript for invoking a particular `C` function 
  - `EXPORTED_FUNCTIONS="['_main', '_run_test']"` - Complementary to `EXPORTED_RUNTIME_METHODS`, only that it is applicable in the context of the target binary. This is similar to Docker's `expose` vs `publish` ports. `EXPORTED_FUNCTIONS` would stand for `expose` in this case.
- `LINKER_OPT`, libraries that our programs will need to be linked to.

### Explorting the project

Run a local Python3 provided HTTP server as usual with:

```shell
# cd into bitmap if not there already
cd bitmap
# assumes presence of python3 on your host system
python3 -m http.server 10003
```

Click `Load` button, you should see something like this:
![Bitmap screeenshot](images/bitmap_screenshot.png)

You may also see that you are able to read from the emulated file system using Dev Tools console in the browser:

```javascript
> var image = FS.readFile("./test20_julia_set_vga.bmp");
<- undefined
> image
<- Uint8Array(2880054) [66, 77, 54, 242, 43, 0, 0, 0, 0, 0, 54, 0, 0, 0, 40, 0, 0, 0, 176, 4, 0, 0, 32, 3, 0, 0, 1, 0, 24, 0, 0, 0, 0, 0, 0, 242, 43, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, …]
```

Additionally, thanks to the swtich statement in [bitmap_image.cpp](bitmap/bitmap_image.cpp):

```cpp
int main(int argc, char **argv)
{
  int which = 20;

  if(argc > 1) {
    std::string::size_type sz;
    which = std::stoi(argv[1], &sz);
  }

  switch(which) {
  case 0:
...
```

we can also load other images (select a corresponding digit from the `<select />` element. Note that
some functions require another bitmap image as input, for those a warning console log will be called:

```javascript
Module.callMain(["1"])
bitmap_test.js:1546 Sorry, 1 requires reading in a file which we are not supporting yet.
```

It is noteworthy that using the `FS` module we can analyze the emulated file system that is being loaded
by WebAssembly Virtual Machine:

```javascript
Before test - CWD: /
(index):87 Before test - Files: (6) ['.', '..', 'tmp', 'home', 'dev', 'proc']
(index):93 After test - Files: (8) ['.', '..', 'tmp', 'home', 'dev', 'proc', 'test19_cartesian_canvas01.bmp', 'test19_cartesian_canvas02.bmp']
(index):119 Uint8Array(3007058) [66, 77, 82, 226, 45, 0, 0, 0, 0, 0, 54, 0, 0, 0, 40, 0, 0, 0, 233, 3, 0, 0, 233, 3, 0, 0, 1, 0, 24, 0, 0, 0, 0, 0, 28, 226, 45, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, …]
(index):120 Successfully displayed image: test19_cartesian_canvas01.bmp
```
